# 全球变暖

??? question "[问题描述](https://www.lanqiao.cn/problems/178/learning/)"

    给定一个 $n \times n$ 的像素网格，每一个像素都存一个字符，存储的字符要么是 `.` 要么是 `#`.

    现规定 `.` 代表海洋，`#` 代表陆地.

    "上下左右" 四个方向上连在一起的陆地组成一个岛屿，由于全球变暖导致了海平面上升，岛屿与海洋有接触部分的陆地将会消失变成海洋.

    数据保证第 $1$ 行、第 $1$ 列、第 $n$ 行、第 $n$ 列都是海洋包围着的.

    问最终消失了多少个岛屿？

    **数据范围**

    $1 \leq n \leq 1000$.

    **输入输出**

    输入第一行代表一个整数 $n$.

    接下来 $n$ 行 $n$ 列分别代表各自像素存放的字符.

    输出一行代表答案.

    **样例一**

    输入：

    ```
    7
    .......
    .##....
    .##....
    ....##.
    ..####.
    ...###.
    .......
    ```

    输出：

    ```
    1
    ```

## 并查集

合并连通分量，并统计连通分量的个数，寻找有多少个连通分量包含内部陆地.

??? question "代码参考"

    ```c++
    LL n, res;
    char g[1010][1010];
    LL bc[N], hg[N], ir[N];
    unordered_set<LL> ct;

    inline LL f(LL x, LL y) { return (x - 1) * n + y; } 

    void init() 
    {
        for (LL i = 1; i <= n; i ++)
        {
            for (LL j = 1; j <= n; j ++)
            {
                bc[f(i, j)] = f(i, j); 
                if (g[i][j] == '#') ir[f(i, j)] = 1;
            }
        }
    }

    LL find(LL x) 
    {
        if (bc[x] == x) return x;
        else return bc[x] = find(bc[x]);
    }

    void meld(LL x, LL y)
    {
        LL a = find(x), b = find(y);
        if (a == b) return;
        if (hg[a] == hg[b]) bc[a] = b, hg[b] ++, ir[a] = 0, ir[b] = 1;
        else if (hg[a] < hg[b]) bc[a] = b, ir[a] = 0, ir[b] = 1;
        else bc[b] = a, ir[b] = 0, ir[a] = 1;
    }

    bool ok(LL x, LL y)
    {
        return (g[x][y] == '#' && g[x - 1][y] == '#' && g[x + 1][y] == '#' && g[x][y - 1] == '#' && g[x][y + 1] == '#');
    }

    void solve(void)
    {
        n = gll();
        for (LL i = 1; i <= n; i ++) scanf ("%s", g[i] + 1);

        init();

        for (LL i = 1; i <= n; i ++)
        {
            for (LL j = 1; j <= n; j ++)
            {
                if (g[i][j] == '.') continue;
                if (g[i - 1][j] == '#') meld(f(i - 1, j), f(i, j));
                if (g[i][j - 1] == '#') meld(f(i, j - 1), f(i, j));
            }
        }

        for (LL i = 1; i <= n; i ++)
        {
            for (LL j = 1; j <= n; j ++)
            {
                if (ir[f(i, j)]) res ++;
                if (ok(i, j)) ct.insert(find(f(i, j)));
            }
        }

        cout << res - ct.size() << endl;
    }
    ```