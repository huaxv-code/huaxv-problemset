# 最小划分

??? question "[问题描述](https://www.lintcode.com/problem/724/)"

    给定一个长为 $n$ 的正整数数组 $S$，请你将 $S$ 分成两部分 $S_1$ 和 $S_2$，使得这两部分的和的差值最少.

    **样例一**

    ```
    输入: nums = [1, 6, 11, 5]
    输出: 1
    解释: 
    Subset1 = [1, 5, 6]，和是12
    Subset2 = [11]，和是11
    abs(11 - 12) = 1
    ```

# 01 背包 + 线性 dp

从左自右，对于第 $i$ 个元素到底是放入背包 $S_1$ 还是背包 $S_2$ 有两种状态.

如果我们已经求出了前 $i - 1$ 个元素划分的最优结果时，那么对于第 $i$ 个元素到底是放入 $S_1$ 还是 $S_2$ 呢？为了使得差值最少，那么新来的正整数应该插入到和最少的一边.

令 $dp[i][0]$ 表示对于前 $i$ 个元素最优划分时的 $S_1$ 的和，$dp[i][1]$ 表示对于前 $i$ 个元素最优划分时的 $S_2$ 的和.

其实这个思路还是 *有问题* 的，例如：

对于数组 $[1, 2, 3]$ 来说，如果按照上面的思路划分最终会变成：$[1, 3]$ 和 $[2]$ 然而最优结果应该为 $[1, 2]$ 与 $[3]$.

---

考虑最终态：

最终结果势必会有一个背包的总和 $\leq sum(S)$ 成立，那么我们就要寻找最优的结果使得其总和最接近 $sum(S)$ 但不能超过 $sum(S)$.

也就是说对于不规则物品，我们要尽可能地装满容量为 $sum(S)$ 的背包.

我们令每一个数的数值等于其消耗容量与价值，在不超过容量为 $sum(S)$ 的前提下，去求最大价值.

??? success "代码参考"

    ```c++
    class Solution {
    public:
        int findMin(vector<int> &nums) {
            long long n = nums.size(), sum = 0, m;
            vector<long long> dp(400000, 0), q(400000, 0);
            for (int i = 1; i <= n; i ++)
                sum += q[i] = nums[i - 1];
            m = sum / 2; // 整数相加绝对不可能出现小数，向下取整.
            for (int i = 1; i <= n; i ++)
            {
                for (int j = m; j; j --)
                {
                    if (j - q[i] >= 0) dp[j] = max(dp[j], dp[j - q[i]] + q[i]);
                }
            }
            return sum - 2 * dp[m];
        }
    };
    ```