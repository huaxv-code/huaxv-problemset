# 最长公共子序列

??? question "[问题描述](https://www.luogu.com.cn/problem/P1439)"

    给出 $1$, $2$, $\cdots$, $n$ 的两个排列 $p_1$ 和 $p_2$，求他们两个的最长公共子序列.

    **数据范围**

    $1 \leq n \leq 10 ^ 5$

    **输入输出**

    【输入格式】

    第一行输入一个整数 $n$

    接下来的 $2$ 行，每行输入 $n$ 个整数，代表 $p_1$ 和 $p_2$

    【输出格式】

    输出只有一个整数，代表答案.

    **样例一**

    输入：

    ```
    5 
    2 1 3 4 5
    1 2 3 4 5
    ```

    输出：

    ```
    4
    ```

    解释：

    2、3、4、5 在两个排列中的相对位置一样.

    [2、3、4、5] 是排列 $p_1$ 和 $p_2$ 的子序列，且相同，且长度最大。

## 最长公共子序列

令 $dp[i][j]$ 代表序列 $p_1$ 的前 $i$ 个字符与序列 $p_2$ 的前 $j$ 个字符的最大子序列.

如果 $p_1[i] = p_2[j]$ 则 $dp[i][j] = dp[i-1][j-1] + 1$;

如果 $p_1[i] != p_2[j]$ 则 $dp[i][j] = max(dp[i][j-1], dp[i-1][j])$;

??? warning "代码参考"

    数据范围在 $10 ^ 5$，用动态规划做会超内存！

    ```c++
    LL n;
    LL p1[1010], p2[1010];
    LL dp[1010][1010];

    void solve(void)
    {
        n = gll();
        for (LL i = 1; i <= n; i ++)
            p1[i] = gll();
        for (LL i = 1; i <= n; i ++)
            p2[i] = gll();

        for (LL i = 1; i <= n; i ++)
        {
            for (LL j = 1; j <= n; j ++)
            {
                if (p1[i] == p2[j])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
            }
        }

        cout << dp[n][n] << endl;
    }
    ```

****