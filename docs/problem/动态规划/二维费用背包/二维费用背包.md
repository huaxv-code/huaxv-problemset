# 二维费用背包

??? question "[二维费用背包](https://www.luogu.com.cn/problem/P1855)"

    有 $n$ 个任务需要完成，完成第 $i$ 个任务需要消耗时间 $t_i$，消耗费用 $w_i$.

    现在有时间 $T$ 和总费用 $W$ 去处理这些任务.

    求最多可以完全多少个任务？

    **数据范围**

    $1 \leq n \leq 100$.

    $0 \leq w_i, t_i \leq 200$.

    **输入输出**

    【输入格式】

    第一行输入 $3$ 个整数，分别代表 $n$、$W$、$T$.

    接下来的 $n$ 行分别输入 $w_i$、$t_i$.

    【输出格式】

    输出只有一行代表结果.

    **样例一**

    输入：

    ```
    6 10 10
    1 1
    2 3 
    3 2
    2 5
    5 2
    4 3
    ```

    输出：

    ```
    4
    ```

## 二维费用问题

令 $dp[i][j][k]$ 代表处理前 $i$ 项任务时，投入金钱 $j$ 和时间 $k$ 的情况下所能获得的最多任务数.

摆在 $dp[i][j][k]$ 面前的问题是第 $i$ 项任务到底是做还是不做？

如果做，那么就得投入金钱 $j - w_i$ 和时间 $k - t_i$ 去处理前 $i - 1$ 件任务的情况下的最大值 + 1；

如果不做，那么就得投入金钱 $j$ 和时间 $k$ 去处理前 $i - 1$ 件任务的情况下的最大值.

所以递推方程为：

> $dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - w_i][k - t_i] + 1)$

因为只与前面的状态有关且数据量有 200 左右，如果用三维数组好像内存空间仍然够用，但推荐改进成二维滚动数组.(从尾部到前面，限定只有一个物品的 01 背包问题！)

??? success "三维数组代码参考"

    *二维数组消耗空间：37.79MB*

    ```c++
    LL n, W, T, w[N], t[N];
    LL dp[210][210][210];

    void solve(void)
    {
        n = gll(), W = gll(), T = gll();
        for (LL i = 1; i <= n; i ++)
            w[i] = gll(), t[i] = gll();

        for (LL i = 1; i <= n; i ++)
        {
            for (LL j = 0; j <= W; j ++)
            {
                for (LL k = 0; k <= T; k ++)
                {
                    dp[i][j][k] = dp[i - 1][j][k];
                    if (j - w[i] >= 0 && k - t[i] >= 0)
                    {
                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - w[i]][k - t[i]] + 1);
                    }
                }
            }
        }

        pll(dp[n][W][T]);
    }
    ```

??? success "二维数组代码参考"

    *二维数组消耗空间：2.76MB*

    ```c++
    LL n, W, T, w[N], t[N];
    LL dp[210][210];

    void solve(void)
    {
        n = gll(), W = gll(), T = gll();
        for (LL i = 1; i <= n; i ++)
            w[i] = gll(), t[i] = gll();

        for (LL i = 1; i <= n; i ++)
        {
            for (LL j = W; j >= 0; j --)
            {
                for (LL k = T; k >= 0; k --)
                {
                    if (j - w[i] >= 0 && k - t[i] >= 0)
                    {
                        dp[j][k] = max(dp[j][k], dp[j - w[i]][k - t[i]] + 1);
                    }
                }
            }
        }

        pll(dp[W][T]);
    }
    ```