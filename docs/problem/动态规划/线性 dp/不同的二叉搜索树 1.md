# 不同的二叉搜索树 1

??? question "[问题描述](https://leetcode.cn/problems/unique-binary-search-trees-ii/description/)"

    给定一个整数 $n$，请你生成并返回所有由 $n$ 个节点组成，且值为 $1 \sim n$ 的互不相同的不同二叉搜索树.

    可以按任意顺序返回.

    ??? info "示例图"
        ![](./img/uniquebstn3.jpg){width="60%"}

    **数据范围**

    $1 \leq n \leq 8$.

    **样例一**

    ```
    输入：n = 3
    输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]
    ```

    **样例二**

    ```
    输入：n = 1
    输出：[[1]]
    ```

## 线性 dp + 暴力求解

令 $dp[i][j]$ 表示成以 $j$ 作为根节点，且总节点数为 $i$ 的二叉搜索树构成的集合.

那么对于 $dp[i][j]$ 来说，其左子树的节点个数可能为：$nums(left) \in \{0, 1, \cdots, i - 1\}$，相应的，其右子树的节点个数为：$nums(right) = i - 1 - nums(left)$.

暴力枚举所有可以构成左子树和右子树的节点然后合并成新的二叉搜索树.

时间复杂度估测应该大于 $O(n ^ 7)$.

??? success "代码参考"

    ```c++
    /**
    * Definition for a binary tree node.
    * struct TreeNode {
    *     int val;
    *     TreeNode *left;
    *     TreeNode *right;
    *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
    *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
    * };
    */
    class Solution {
    public:
        vector<TreeNode*> dp[10][10];
        bool lok(TreeNode* rt, int x)
        {
            if (rt == nullptr) return true;
            if (rt->val >= x) return false;
            int bl = lok(rt->left, x);
            if (bl == false) return false;
            return lok(rt->right, x);
        }
        bool rok(TreeNode* rt, int x)
        {
            if (rt == nullptr) return true;
            if (rt->val <= x) return false;
            int bl = rok(rt->left, x);
            if (bl == false) return false;
            return rok(rt->right, x);
        }
        vector<TreeNode*> generateTrees(int n) {
            for (int i = 1; i <= n; i ++)
                dp[1][i].push_back(new TreeNode(i, nullptr, nullptr));
            for (int i = 2; i <= n; i ++)
            {
                for (int j = 1; j <= n; j ++)
                {
                    for (int k = 0; k < i; k ++)
                    {
                        if (k == 0)
                        {
                            for (int y = n; y > j; y --)
                                for (auto r : dp[i - 1 - k][y])
                                    if (rok(r, j)) dp[i][j].push_back(new TreeNode(j, nullptr, r));
                        }
                        else if (k == i - 1)
                        {
                            for (int x = 1; x < j; x ++)
                                for (auto l : dp[k][x])
                                    if (lok(l, j)) dp[i][j].push_back(new TreeNode(j, l, nullptr));
                        }
                        else
                        {
                            for (int x = 1; x < j; x ++)
                            {
                                for (int y = n; y > j; y --)
                                {
                                    for (auto l : dp[k][x])
                                    {
                                        for (auto r : dp[i - 1 - k][y])
                                            if (lok(l, j) && rok(r, j)) dp[i][j].push_back(new TreeNode(j, l, r));
                                    }
                                }
                            }
                        }
                    }
                }
            }
            vector<TreeNode*> res;
            for (int i = 1; i <= n; i ++)
                for (auto t : dp[n][i])
                    res.push_back(t);
            return res;
        }
    };
    ```