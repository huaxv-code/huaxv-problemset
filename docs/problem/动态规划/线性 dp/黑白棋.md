# 黑白棋

**由简到繁：**

*如果一个大问题很复杂，不妨先尝试解决关于它的小问题或者简单问题。*

??? question "[问题描述](https://www.luogu.com.cn/problem/T313402?contestId=101142)"

    有 $p$ 个黑棋和 $q$ 个白棋排一列.

    规定：

    - 黑棋不能连续出现超过 $r$ 个；
    - 白棋不能连续出现超过 $s$ 个；

    问一共有多少种排法.

    结果要对 $10 ^ 8$ 取模.

    **数据范围**

    $1 \leq p, q \leq 100$

    $1 \leq r, s \leq 10$

    **输入输出**

    【输入格式】

    输入只有一行，有 $4$ 个整数，分别代表 $p、q、r、s$

    【输出格式】

    输出只有一个整数，代表最终结果.

    **样例一**

    输入：

    ```
    28 65 5 9
    ```

    输出：

    ```
    83961789
    ```

## 由简到繁 + 线性 dp

**由简到繁：**

如果我们不考虑不能连续出现多少个的问题，就单单将问题模型简化成：

- 给定 $p$ 个黑棋和 $q$ 个白棋，问有多少种排列方式.
  
自由变量有两个：{==黑旗的数量==} 和 {==白棋的数量==}

所以定义二维 $dp[i][j]$ 表示成将前 $i$ 颗黑棋和前 $j$ 颗白棋排成一列有多少种排列方式.

又由于对于当前插入的球到底是黑棋还是白棋，有两种未知的状态，所以要定义 $3$ 维 $dp[i][j][k]$ 如果 $k$ 是 $0$ 代表插入黑棋，如果 $k = 1$ 代表此时插入白棋.

那么假设此时要插入的黑棋，且 $dp[i - 1][j]$ 已知的前提下，该黑棋能在前 $0，1，\cdots，i + j - 1$ 号位置中插入，难道插入黑棋时的排列方式有：$(i + j) * dp[i - 1][j]$ 那么多种？

不不不，会有重复！

但是最后那个位置只有两种可能的结果，要么是黑色，要么就是白色，而前面 $i + j - 1$ 个棋的排列一定是在子问题中就已经出现了的

所以，如果此时是插入黑棋的情况下：

如果最后一个位置是黑棋的前提下，

那么前面 $i + j - 1$ 号棋就是由 $i - 1$ 个黑棋，和 $j$ 个白棋自由排列的结果，所以有 $dp[i - 1][j]$ 种可能；

如果最后一个位置是白棋的前提下，

那么前面 $i + j - 1$ 号棋是由 $i$ 个黑棋，和 $j - 1$ 个白棋自由排列的结果，所以有 $dp[i][j - 1]$ 种可能；

如果此时是插入白棋的情况下：

如果最后一个位置是黑棋的前提下，

那么前面 $i + j - 1$ 号棋就是由 $i - 1$ 个黑棋，和 $j$ 个白棋自由排列的结果，所以有 $dp[i - 1][j]$ 种可能；

如果最后一个位置是白棋的前提下，

那么前面 $i + j - 1$ 号棋是由 $i$ 个黑棋，和 $j - 1$ 个白棋自由排列的结果，所以有 $dp[i][j - 1]$ 种可能；

所以递推方程：

> $dp[i][j][0] = dp[i - 1][j] + dp[i][j - 1]$
>
> $dp[i][j][1] = dp[i - 1][j] + dp[i][j - 1]$

然而这样思考还是会有重复，重复了两倍，完全没必要分开插入的是黑棋还是白棋来讨论，参考代码:

??? note "参考代码"

    ```c++
    LL n, m;
    LL dp[2000][2000];
    LL mod = 100000000;

    void solve(void)
    {
        n = gll(), m = gll();
        for (LL i = 0; i <= n; i ++)
            dp[i][0] = 1;
        for (LL i = 0; i <= m; i ++)
            dp[0][i] = 1;
        for (LL i = 1; i <= n; i ++)
        {
            for (LL j = 1; j <= m; j ++)
            {
                dp[i][j] += dp[i - 1][j] + dp[i][j - 1];
                dp[i][j] %= mod;
            }
        }
        pll(dp[n][m]);
    }
    ```

---

原题多了个限制条件，不能连续出现超过 $r$ 个黑棋，不能连续出现超过 $s$ 个白棋.

如果当前要插入的是黑棋，那么插入前 $i - 1$ 颗黑棋和前 $j$ 颗白棋时，虽然有 $dp[i - 1][j]$ 那么多种排列方法，但是到达插入黑棋时，万一末尾已经出现了连续 $r$ 个黑棋该怎么办？此时是不能插入了的啊，所以还需要开辟出两维分别记录末尾出现 $k$ 个黑棋、$l$ 个白棋的前提下有多少种排法：

定义：

$dp[i][j][k][l]$ 的含义为将前 $i$ 颗黑棋，前 $j$ 颗白棋，排列成末尾出现 $k$ 颗黑棋或者 $l$ 颗白棋的前提下的排列方法次数.

那么如果对于当前要插入的黑棋，那么就要一一遍历末尾出现 $1 \leq x \leq r - 1$ 颗黑棋的情况，逐一讨论

??? success "代码参考"

    ```c++
    LL n, m, r, s;
    LL dp[200][200][20][20];
    LL mod = 100000000;

    void solve(void)
    {
        n = gll(), m = gll();
        r = gll(), s = gll();
        for (LL i = 0; i <= n && i <= r; i ++)
            dp[i][0][i][0] = 1;
        for (LL i = 0; i <= m && i <= s; i ++)
            dp[0][i][0][i] = 1;
        
        for (LL i = 1; i <= n; i ++)
        {
            for (LL j = 1; j <= m; j ++)
            {
                for (LL k = 1; k <= r; k ++)
                {
                    if (i - k >= 0)
                    {
                        for (LL l = 1; l <= s; l ++)
                        {
                            dp[i][j][k][0] += dp[i - k][j][0][l];
                            dp[i][j][k][0] %= mod;
                        }
                    }
                }
                for (LL k = 1; k <= s; k ++)
                {
                    if (j - k >= 0)
                    {
                        for (LL l = 1; l <= r; l ++)
                        {
                            dp[i][j][0][k] += dp[i][j - k][l][0];
                            dp[i][j][0][k] %= mod;
                        }
                    }
                }
            }
        }

        LL res = 0;
        for (LL i = 1; i <= r; i ++)
            res = (res + dp[n][m][i][0]) % mod;
        for (LL i = 1; i <= s; i ++)
            res = (res + dp[n][m][0][i]) % mod;
        pll(res);
    }
    ```