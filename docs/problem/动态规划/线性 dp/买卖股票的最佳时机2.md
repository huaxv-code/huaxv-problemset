# 买卖股票的最佳时机 2

??? question "[问题描述](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)"

    给你一个股票波动整数数组 $a[n]$，其中 $a[i]$ 表示第 $i$ 天卖出可以获得 $a[i]$ 元.

    你最多只能同时含有某一天的股票，你可以合理地安排时候售出，来赚取中间差价，例如有股票波动整数数组 $a[n] = \{7, 1, 5, 6, 9\}$

    你可以选择第 $2$ 天用 $1$ 块钱买下，然后第 $5$ 天用 $9$ 块钱售出，这样就可以赚取 $8$ 块钱.

    请你设计一个程序，使得可获差价最高.

    **样例一**

    ```
    输入：prices = [7,1,5,3,6,4]
    输出：7
    解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
        随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
        总利润为 4 + 3 = 7 。
    ```

    **样例二**

    ```
    输入：prices = [1,2,3,4,5]
    输出：4
    解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
        总利润为 4 。
    ```

    **样例三**

    ```
    输入：prices = [7,6,4,3,1]
    输出：0
    解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
    ```

## 贪心 + 线性 dp

如果 $i$ 天购入，需要花费 $a[i]$ 元，在第 $i$ 天后面有 $j$、$j + a$、$j + b$、$\cdots$、$j + z$ 那么多天抛售的价格比 $a[i]$ 还大，此时就能获得中间差价，那到底应该选取哪一天售出呢？是选择第 $j$ 天还是第 $j + z$ 天？亦或是中间差价最大的那一天？

如果是选择第 $j$ 天售出，那么我们仍然还可以在第 $j$ 天购入，最高那一天售出

最优方案就是在距离最近的比它的大的那一天售出，这样才会有更多的机会在后面继续购入继续售出.

那么对于当天也可以不用购买，此时的最优方案就是前面那些天售出的最优方案，使用相邻滚动，可以不断的把最优值向右滚动.

对于每一天来说，如何获取右边第一个比它的天数下标？

- 借助单调栈，如果新插入的元素比较大，那么就把栈顶所有比新元素小的元素都指向该新元素.

时间复杂度：$O(n)$

??? success "代码参考"

    ```c++
    class Solution {
    public:

        vector<int> a, b;
        vector<int> dp;
        int n;

        // 获取右边第一个比 a[i] 大的元素的下标
        void grb()
        {
            stack<int> st;
            for (int i = 1; i <= n; i ++)
            {
                if (st.empty())
                    st.push(i);
                else
                {
                    auto p = st.top();
                    while (a[p] <= a[i])
                    {
                        b[p] = i; 
                        st.pop();
                        if (st.empty()) break;
                        p = st.top();
                    }

                    st.push(i);
                }
            }
        }

        int maxProfit(vector<int>& prices) {
            n = prices.size();

            a = vector<int>(n + 10, 0);
            for (int i = 1; i <= n; i ++)
                a[i] = prices[i - 1];
            dp = b = vector<int> (n + 10, 0);

            grb();

            for (int i = 1; i <= n; i ++)
            {
                dp[b[i]] = max(dp[i] + a[b[i]] - a[i], dp[b[i]]);
                dp[i + 1] = max(dp[i], dp[i + 1]);
            }

            return dp[n];
        }
    };
    ```