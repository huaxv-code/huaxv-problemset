# 海底高铁

??? question "[问题描述](https://www.luogu.com.cn/problem/P3406)"

    # 海底高铁

    ## 题目背景

    ## 题目描述

    该铁路经过 $N$ 个城市，每个城市都有一个站。不过，由于各个城市之间不能协调好，于是乘车每经过两个相邻的城市之间（方向不限），必须单独购买这一小段的车票。第 $i$ 段铁路连接了城市 $i$ 和城市 $i+1(1\leq i<N)$。如果搭乘的比较远，需要购买多张车票。第 $i$ 段铁路购买纸质单程票需要 $A_i$ 博艾元。

    虽然一些事情没有协调好，各段铁路公司也为了方便乘客，推出了 IC 卡。对于第 $i$ 段铁路，需要花 $C_i$ 博艾元的工本费购买一张 IC 卡，然后乘坐这段铁路一次就只要扣 $B_i(B_i<A_i)$ 元。IC 卡可以提前购买，有钱就可以从网上买得到，而不需要亲自去对应的城市购买。工本费不能退，也不能购买车票。每张卡都可以充值任意数额。对于第 $i$ 段铁路的 IC 卡，无法乘坐别的铁路的车。

    Uim 现在需要出差，要去 $M$ 个城市，从城市 $P_1$ 出发分别按照 $P_1,P_2,P_3,\cdots,P_M$ 的顺序访问各个城市，可能会多次访问一个城市，且相邻访问的城市位置不一定相邻，而且不会是同一个城市。

    现在他希望知道，出差结束后，至少会花掉多少的钱，包括购买纸质车票、买卡和充值的总费用。

    ## 输入格式

    第一行两个整数，$N,M$。

    接下来一行，$M$ 个数字，表示 $P_i$。

    接下来 $N-1$ 行，表示第 $i$ 段铁路的 $A_i,B_i,C_i$。

    ## 输出格式

    一个整数，表示最少花费

    ## 样例 #1

    ### 样例输入 #1

    ```
    9 10
    3 1 4 1 5 9 2 6 5 3
    200 100 50
    300 299 100
    500 200 500
    345 234 123
    100 50 100
    600 100 1
    450 400 80
    2 1 10
    ```

    ### 样例输出 #1

    ```
    6394
    ```

    ## 提示

    $2$ 到 $3$ 以及 $8$ 到 $9$ 买票，其余买卡。

    对于 $30\%$ 数据 $M=2$。

    对于另外 $30\%$ 数据 $N\leq1000，M\leq1000$。

    对于 $100\%$ 的数据 $M,N\leq 10^5，A_i,B_i,C_i\le10^5$。

## 前缀差分

若有 $9$ 个城市，它若想要依次到达城市 $3 \rightarrow 1 \rightarrow 4 \rightarrow 1 \rightarrow 5 \rightarrow 9\rightarrow 2 \rightarrow 6 \rightarrow 5 \rightarrow 3$，则会有 *某些铁路段需要重复经过*；

如果某条铁路 $i$ 可能只经过一次，它的花费可能比买卡的花费要低，例如：$A[i] < B[i] + C[i]$，但由于 $B[i] < A[i]$ 的，若该铁路经过了很多次，假设有 $t$ 次，那么不等式：$A[i] * t > B[i] * t + C[i]$ 是很有可能成立的；

所以我们需要求出各个铁路段需要搭乘的次数，这样就转换成了 **区间重叠问题**；

若某铁路的入口出口分别为城市 $[x, y]$ 那么标记入口个数 $a[x] += 1$ 标记出口个数 $b[y + 1] += 1$，最终可以用差分思想的数据叠加方式，从左边依次叠加，看看到达该城市时，比之前多进入了多少个铁路，又出去了多少个铁路，所以需要达成该城市的铁路个数为：$c[i] = c[i + 1] + a[i] - b[i + 1]$，对于每一段铁路的最小花费为：

> $min(A[i] * c[i], B[i] * c[i] + C[i])$

??? success "代码参考"

    ```c++
    LL n, m, res;
    LL q[N], a[N], b[N], c[N];
    LL A[N], B[N], C[N];

    void solve(void)
    {
        cin >> n >> m;
        for (LL i = 1; i <= m; i ++) cin >> q[i];
        for (LL i = 1; i < n; i ++) 
        {
            cin >> A[i] >> B[i] >> C[i];
        }
        for (LL i = 1; i < m; i ++)
        {
            a[min(q[i], q[i + 1])] += 1;
            b[max(q[i], q[i + 1]) + 1] += 1;
        }
        // 总共有 n 个城市，终点得到达 n + 1 越出一界
        // 从左边开始向右走统计进入多少段铁路，出去多少段铁路
        for (LL i = 1; i <= n; i ++)
        {
            c[i] = c[i - 1] + a[i] - b[i + 1];
        }
        for (LL i = 1; i <= n; i ++)
        {
            res += min(A[i] * c[i], B[i] * c[i] + C[i]);
        }
        cout << res << endl;
    }
    ```