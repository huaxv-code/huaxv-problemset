# 期末成绩

??? question "[题目描述](https://www.luogu.com.cn/problem/P3745)"

    # [六省联考 2017] 期末考试

    ## 题目描述

    有 $n$ 位同学，每位同学都参加了全部的 $m$ 门课程的期末考试，都在焦急的等待成绩的公布。

    第 $i$ 位同学希望在第 $t_i$ 天或之前得知**所有**课程的成绩。如果在第 $t_i$ 天，有至少一门课程的成绩没有公布，他就会等待最后公布成绩的课程公布成绩，每等待一天就会产生 $C$ 不愉快度。

    对于第 $i$ 门课程，按照原本的计划，会在第 $b_i$ 天公布成绩。

    有如下两种操作可以调整公布成绩的时间:
    1. 将负责课程 $X$ 的部分老师调整到课程 $Y$，调整之后公布课程 $X$ 成绩的时间推迟一天，公布课程 $Y$ 成绩的时间提前一天；每次操作产生 $A$ 不愉快度。
    2. 增加一部分老师负责学科 $Z$，这将导致学科 $Z$ 的出成绩时间提前一天；每次操作产生 $B$ 不愉快度。

    上面两种操作中的参数 $X, Y, Z$ 均可任意指定，每种操作均可以执行多次，每次执行时都可以重新指定参数。

    现在希望你通过合理的操作，使得最后总的不愉快度之和最小，输出最小的不愉快度之和即可。

    ## 输入格式

    第一行三个非负整数 $A, B, C$，描述三种不愉快度，详见【题目描述】；  
    第二行两个正整数 $n, m$，分别表示学生的数量和课程的数量；  
    第三行 $n$ 个正整数 $t_i$，表示每个学生希望的公布成绩的时间；  
    第四行 $m$ 个正整数 $b_i$，表示按照原本的计划，每门课程公布成绩的时间。

    ## 输出格式

    输出一行一个整数，表示最小的不愉快度之和。

    ## 样例 #1

    ### 样例输入 #1

    ```
    100 100 2
    4 5
    5 1 2 3
    1 1 2 3 3
    ```

    ### 样例输出 #1

    ```
    6
    ```

    ## 样例 #2

    ### 样例输入 #2

    ```
    3 5 4
    5 6
    1 1 4 7 8
    2 3 3 1 8 2
    ```

    ### 样例输出 #2

    ```
    33
    ```

    ## 提示

    ### 样例解释 1

    由于调整操作产生的不愉快度太大，所以在本例中最好的方案是不进行调整；全部的 $5$ 门课程中，最慢的在第 $3$ 天出成绩；  
    同学 $1$ 希望在第 $5$ 天或之前出成绩，所以不会产生不愉快度；  
    同学 $2$ 希望在第 $1$ 天或之前出成绩，产生的不愉快度为 $(3 - 1) \times 2 = 4$；  
    同学 $3$ 希望在第 $2$ 天或之前出成绩，产生的不愉快度为 $(3 - 2) \times 2 = 2$；  
    同学 $4$ 希望在第 $3$ 天或之前出成绩，所以不会产生不愉快度；  
    不愉快度之和为 $4 + 2 = 6$。

    ### 数据范围

    | Case # | $n, m, t_i, b_i$ | $A, B, C$ |
    |:-:|:-:|:-:|
    | 1, 2 | $1 \leq n, m, t_i, b_i \leq 2000$ | $A = 10^9; B = 10^9; 0 \leq C \leq 10^2$ |
    | 3, 4 | $1 \leq n, m, t_i, b_i \leq 2000$ | $0 \leq A; C \leq 10^2; B = 10^9$ |
    | 5, 6, 7, 8 | $1 \leq n, m, t_i, b_i \leq 2000$ | $0 \leq B \leq A \leq 10^2; 0 \leq C \leq 10^2$ |
    | 9 - 12 | $1 \leq n, m, t_i, b_i \leq 2000$ | $0 \leq A, B, C \leq 10^2$ |
    | 13, 14 | $1 \leq n, m, t_i, b_i \leq 10^5$ | $0 \leq A, B \leq 10^5; C = 10^{16}$ |
    | 15 - 20 | $1 \leq n, m, t_i, b_i \leq 10^5$ | $0 \leq A, B, C \leq 10^5$ |`

## 三分法

决定每个同学不愉快度的，取决于最后一个出成绩的科目的时间.

如果要降低每个同学的不愉快度，就要想办法缩短最后一个出成绩的科目时间.

你可以假设最后一个出成绩的科目的时间都缩短为 $t$ 那么看一下有多少个科目的出成绩时间是超过 $t$ 的，超出部分累计为 $x$.

因为可以通过一降一升来缩短最后科目出成绩的时间，而那些小于时间 $t$ 的科目低于 $t$ 的部分也累计起来，记为 $y$.

如果 $x > y$ 则我们可以通过降低 $y$ 升高 $y$ 的办法来缩短部分最高值的天数，看一下需要积累多少个不愉快度 $A$，如果积累的不愉快度比直接降低 $y$ 次积累的多少个不愉快度 $B$ 累计值还要高，那就直接采取降低措施来的愉快.

首先 $t$ 的选取不是越低越好，如果越来越低，会使得通过降低天数导致积累的不愉快度升高.

$t$ 的选取也不是越高越好，如果越来越高，就会使得同学们积累的复杂度没有根本性的改善，还是维持原样.

所以 $t$ 有个合适值使得不愉快度最低，该函数是关于 $t$ 的下凹函数.

三分法解决凸凹函数：

!!! warning "大数介绍"

    # 大数介绍

    ## long double 

    ### 字节大小

    **8、10、12、16 字节大小，取决于编译器，不低于 double.**

    ### 改名

    ```c++
    typedef long double DD;
    ```

    ### 输入输出

    输入：

    ```c++
    DD x;
    scanf ("%Lf", &x);

    cin >> x;
    ```

    输出：

    ```c++
    DD x;
    // ···
    printf ("%.0Lf\n", x);
    cout << x << endl;
    ```

    ## __int128

    ### 字节大小

    **16字节，支持 __int128 的一般都支持 long double 16 字节.**

    ### 改名

    ```c++
    typedef __int128 HH;
    ```

    ### 输入输出

    输入：

    ```c++
    inline HH ghh() 
    {   
        HH x = 0, f = 1; char c; 
        c = getchar();
        while (c > '9' || c < '0') { if (c == '-') f = -1; c = getchar(); }
        while (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar(); }
        return x * f;
    }
    ```

    或者

    ```c++
    inline HH ghh() 
    {   
        char s[200];
        scanf ("%s", s);
        HH x = 0, f = 1; char c; 
        for (LL i = 0; s[i]; i ++) 
        {
            if (s[i] == '-') f = -1;
            else if (s[i] >= '0' && s[i] <= '9') x = x * 10 + s[i] - '0';
        }

        return x * f;
    }
    ```

    输出：

    ```c++
    inline void phh(HH x)
    {
        if (x < 0) { putchar('-'); x *= -1; }
        if (x == 0) { putchar('0'); return; }
        if (x / 10) phh(x / 10);
        putchar((x % 10) + '0');
    }
    ```


!!! note "实数三分外壳"

    ```c++
    while (r - l + 1 >= 4) // 可以选取比 4 大的数，最后 for 一遍寻找最优值就行
    {
        // ...
    }
    ```

    **只有还能装 $4$ 个整数时，才够分配给 $l$ 、$m1$ 、$m2$ 、$r$.**

    如果只有 $3$ 个整数时还继续执行，会让 $m1 = m2$，最终导致 $l = m1$ 或者 $r = m2$ 对于 *单调区间* 来说，其答案会在边界处，而只剩 $3$ 个整数时继续允许程序执行，会让 $l = m1$ 或者 $r = m2$ 执行哪一个取决于自己的码风，这样 *正好就避开了边界答案*.

    如果长度只剩 2 了，会导致 $m1$ 去到 $l$ 的左边，$m2$ 去到 $r$ 的右边，从而出现 *死循环* 的现象.

??? success "代码参考"

    ??? success "long double"

        ```c++ title="long double"
        LL a, b, c;
        LL n, m;
        LL ti[N], vi[N];
        LL l, r, m1, m2;

        inline LL rd() { LL t; scanf ("%lld", &t); return t; }

        LD f(LL t)
        {
            LD x = 0, y = 0, sum = 0;
            for (LL i = 1; i <= m; i ++)
            {
                if (vi[i] > t) x += vi[i] - t;
                else y += t - vi[i];
            }

            if (a < b) 
            {
                sum += min(x, y) * a; 
                x = (x > y ? x - y : 0);
            }
            sum += x * b;

            for (LL i = 1; i <= n; i ++)
            {
                sum += (t > ti[i] ? (t - ti[i]) * c : 0);
            }

            return sum;
        }

        void solve(void)
        {
            a = rd(), b = rd(), c = rd();
            n = rd(), m = rd();
            for (LL i = 1; i <= n; i ++) ti[i] = rd();
            for (LL i = 1; i <= m; i ++) { vi[i] = rd(); r = max(r, vi[i]); }

            // 3 分停留条件：长度小于等于 3 时结束循环
            // 3 分是要分成 3 分，需要 4 个整数
            // 如果长度等于 3 时照样执行，此时 l + 1 == m1 == m2 = r - 1
            // 势必会导致 l 移动到 m1 或者 r 移动到 m2 
            // 如果答案恰好就在边界就会出错.
            while (r - l + 1 >= 4) // 把 3 改大一点也行，只需要在 [l, r] 内 for 一遍最小值
            {
                LL k = (r - l + 1) / 3;
                m1 = l + k, m2 = r - k;

                if (f(m1) > f(m2)) l = m1;
                else r = m2;
            }

            LD res = 1e18;
            for (LL i = l; i <= r; i ++)
            {
                res = min(res, f(i));
            }
            printf ("%.0Lf\n", res);
        }
        ```

    ??? success "__int128"
    
        ```c++ title="__int128"
        HH a, b, c;
        HH n, m;
        HH ti[N], vi[N];
        HH l, r, m1, m2;

        inline HH ghh() 
        {   
            char s[200];
            scanf ("%s", s);
            HH x = 0, f = 1; char c; 
            for (LL i = 0; s[i]; i ++) 
            {
                if (s[i] == '-') f = -1;
                else if (s[i] >= '0' && s[i] <= '9') x = x * 10 + s[i] - '0';
            }

            return x * f;
        }

        inline void phh(HH x)
        {
            if (x < 0) { putchar('-'); x *= -1; }
            if (x == 0) { putchar('0'); return; }
            if (x / 10) phh(x / 10);
            putchar((x % 10) + '0');
        }

        inline LL rd() { LL t; scanf ("%lld", &t); return t; }

        HH f(LL t)
        {
            HH x = 0, y = 0, sum = 0;
            for (LL i = 1; i <= m; i ++)
            {
                if (vi[i] > t) x += vi[i] - t;
                else y += t - vi[i];
            }

            if (a < b) 
            {
                sum += min(x, y) * a; 
                x = (x > y ? x - y : 0);
            }
            sum += x * b;

            for (LL i = 1; i <= n; i ++)
            {
                sum += (t > ti[i] ? (t - ti[i]) * c : 0);
            }

            return sum;
        }

        void solve(void)
        {
            a = ghh(), b = ghh(), c = ghh();
            n = ghh(), m = ghh();
            for (LL i = 1; i <= n; i ++) ti[i] = ghh();
            for (LL i = 1; i <= m; i ++) { vi[i] = ghh(); r = max(r, vi[i]); }

            // 3 分停留条件：长度小于等于 3 时结束循环
            // 3 分是要分成 3 分，需要 4 个整数
            // 如果长度等于 3 时照样执行，此时 l + 1 == m1 == m2 = r - 1
            // 势必会导致 l 移动到 m1 或者 r 移动到 m2 
            // 如果答案恰好就在边界就会出错.
            while (r - l + 1 >= 4) // 把 3 改大一点也行，只需要在 [l, r] 内 for 一遍最小值
            {
                LL k = (r - l + 1) / 3;
                m1 = l + k, m2 = r - k;

                if (f(m1) > f(m2)) l = m1;
                else r = m2;
            }

            HH res = 1e18;
            for (LL i = l; i <= r; i ++)
            {
                res = min(res, f(i));
            }
            phh(res);
        }
        ```