# [最近公共祖先](https://www.luogu.com.cn/problem/P3379)

=== "欧拉序 + 节点深度 + 线段树"

    ```java
    #include <bits/stdc++.h>

    using namespace std;
    typedef long long LL;
    typedef long double FF;
    int gii(); LL gll(); FF gff();
    const int N = 2000100;

    int g[N / 4], e[N], ne[N], on[N / 4];
    int cur;

    int de[N / 4], elr[N / 2], st[N / 4];
    int cnt;

    int tr[N * 2], ps[N * 2];

    int n, m, s;

    void dfs(int p) {
        if (on[p]) return;
        on[p] = 1;
        cnt ++;
        st[p] = cnt;
        elr[cnt] = p;
        for (int i = g[p]; i; i = ne[i]) {
            if (on[e[i]] == 0) {
                dfs(e[i]);
                elr[++ cnt] = p;
            }
        }
    }

    void deep(int p, int x) {
        if (on[p]) return;
        on[p] = 1;
        de[p] = x;
        for (int i = g[p]; i; i = ne[i]) {
            if (on[e[i]]) continue;
            deep(e[i], x + 1);
        }
    }

    void add(int a, int b) {
        cur ++;
        e[cur] = b;
        ne[cur] = g[a];
        g[a] = cur;
    }

    inline int lc(int p) { return p << 1; }
    inline int rc(int p) { return p << 1 | 1; }

    void push_up(int p, int l, int r) {
        if (l == r) {
            tr[p] = de[elr[l]];
            ps[p] = elr[l];
            return;
        }

        if (tr[lc(p)] <= tr[rc(p)]) {
            tr[p] = tr[lc(p)];
            ps[p] = ps[lc(p)];
        } else {
            tr[p] = tr[rc(p)];
            ps[p] = ps[rc(p)];
        }
    }

    void build(int p, int l, int r) {
        if (l == r) {
            push_up(p, l, r); return;
        }

        int mid = (l + r) >> 1;
        build(lc(p), l, mid);
        build(rc(p), mid + 1, r);

        push_up(p, l, r);
    }

    vector<int> query(int p, int l, int r, int ll, int rr) {
        if (ll <= l && r <= rr) {
            return {tr[p], ps[p]};
        }

        int mid = (l + r) >> 1;

        vector<int> a = {N * 2, 0};
        if (ll <= mid) {
            a = query(lc(p), l, mid, ll, rr);
        }
        if (rr > mid) {
            auto b = query(rc(p), mid + 1, r, ll, rr);
            if (a[0] > b[0]) a = b;
        }

        return a;
    }

    void solve() {
        
        n = gii(); m = gii(); s = gii();

        for (int i = 1; i < n; i ++) {
            int x = gii();
            int y = gii();
            add(x, y);
            add(y, x);
        }

        deep(s, 1);
        for (int i = 1; i <= n; i ++) on[i] = 0;
        dfs(s);
        
        build(1, 1, cnt);

        for (int i = 1; i <= m; i ++) {
            int x = st[gii()];
            int y = st[gii()];
            if (x > y) {
                int t = x; x = y; y = t;
            }
            printf("%d\n", query(1, 1, cnt, x, y)[1]);
        }
    }

    int main() {

        solve();

        return 0;
    }

    int gii() {
        int n; scanf("%d", &n); return n;
    }

    LL gll() {
        LL n; scanf("%lld", &n); return n;
    }

    FF gff() {
        FF n; scanf("%Lf", &n); return n;
    }
    ```