# 跑路

??? question "[问题描述](https://www.luogu.com.cn/problem/P1613)"

    # 跑路

    ## 题目描述

    小 A 的工作不仅繁琐，更有苛刻的规定，要求小 A 每天早上在 $6:00$ 之前到达公司，否则这个月工资清零。可是小 A 偏偏又有赖床的坏毛病。于是为了保住自己的工资，小 A 买了一个空间跑路器，每秒钟可以跑 $2^k$ 千米（$k$ 是任意自然数）。当然，这个机器是用 `longint` 存的，所以总跑路长度不能超过 `maxlongint` 千米。小 A 的家到公司的路可以看做一个有向图，小 A 家为点 $1$，公司为点 $n$，每条边长度均为一千米。小 A 想每天能醒地尽量晚，所以让你帮他算算，他最少需要几秒才能到公司。数据保证 $1$ 到 $n$ 至少有一条路径。

    ## 输入格式

    第一行两个整数 $n,m$，表示点的个数和边的个数。

    接下来 $m$ 行每行两个数字 $u,v$，表示一条 $u$ 到 $v$ 的边。

    ## 输出格式

    一行一个数字，表示到公司的最少秒数。

    ## 样例 #1

    ### 样例输入 #1

    ```
    4 4
    1 1
    1 2
    2 3
    3 4
    ```

    ### 样例输出 #1

    ```
    1
    ```

    ## 提示

    **【样例解释】**

    $1 \to 1 \to 2 \to 3 \to 4$，总路径长度为 $4$ 千米，直接使用一次跑路器即可。

    **【数据范围】**

    $50\%$ 的数据满足最优解路径长度 $\leqslant 1000$；

    $100\%$ 的数据满足 $n \leqslant 50$，$m \leqslant 10000$，最优解路径长度 $\leqslant$ `maxlongint`。

## 倍增思想

由于最优路径长度最大不超过 $2 ^ {64}$ 次方

如果存在某个通路使得从 $1$ 到 $n$ 的通路长度为 $2 ^ k$ 则只需 $1$ s 就可以跳转到公司.

如果不存在就得找到某通路的长度，它的二进制表示中的 $1$ 的个数最少就是答案.

满足条件的通路中必定存在某个点 $a$ 使得 $1 \sim a$ 的通路长度为 $2 ^ {k_1}$，并且从 $a$ 开始也存在某个点 $b$ 使得 $a \sim b$ 的通路长度为 $2 ^ {k _ 2}$，··· ··· ，直到最后某个到达 $n$ 的通路长度也是 $2 ^ {k _ s}$，且答案正好是：$k_1 + k_2 + \cdots + k_s$.

为此我们要知道任意两点之间是否存在通路长度为 $2 ^ k$：

倍增思想：

从通路长度为 1 的倍增到 2，再由 2 倍增到 4，一直倍增到 $2 ^ {64}$ 为止，找出所有通路长度为 $2 ^ k$ 的点.

标记数组 `g[i][j][k]` 表示点 $j$ 和点 $k$ 之间存在长度为 $2 ^ i$ 的通路，并且，如果 `g[i][j][k] == 1` 且 `g[i][k][l] == 1` 说明 $j$ 和 $l$ 之间存在长度为 $2 ^ {i + 1}$ 的通路，所以 `g[i+1][j][l] = 1`.

数组 `eg[i][j]` 表示点 $i$ 和点 $j$ 之间是否存在长度为 $2 ^ k$ 的通路，并依此寻找最短距离就是答案.

??? success "代码参考"

    ```c++
    LL n, m;
    LL g[N][N][N];
    LL eg[N][N];
    LL st[N];

    void solve(void)
    {
        n = gll(), m = gll();
        for (LL i = 1; i <= m; i ++) 
        {
            LL a = gll(), b = gll();
            eg[a][b] = 1; g[0][a][b] = 1;
        }

        for (LL i = 1; i <= 64; i ++)
        {
            for (LL j = 1; j <= n; j ++)
            {
                for (LL k = 1; k <= n; k ++)
                {
                    for (LL l = 1; l <= n; l ++)
                    {
                        if (g[i - 1][j][k] && g[i - 1][k][l]) g[i][j][l] = 1, eg[j][l] = 1;
                    }
                }
            }
        }

        queue<vector<LL>> q;
        q.push({1, 0});

        while (q.size())
        {
            auto tp = q.front(); q.pop();
            if (st[tp[0]]) continue;
            st[tp[0]] = 1;
            if (tp[0] == n) { cout << tp[1] << endl; return; }
            for (LL i = 1; i <= n; i ++)
            {
                if (eg[tp[0]][i]) q.push({i, tp[1] + 1});
            }
        }
    }
    ```