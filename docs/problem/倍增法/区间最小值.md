# 区间最小值

??? question "[问题描述](https://www.luogu.com.cn/problem/P1816)"

    # 忠诚

    ## 题目描述

    老管家是一个聪明能干的人。他为财主工作了整整  $10$ 年。财主为了让自已账目更加清楚，要求管家每天记  $k$ 次账。由于管家聪明能干，因而管家总是让财主十分满意。但是由于一些人的挑拨，财主还是对管家产生了怀疑。于是他决定用一种特别的方法来判断管家的忠诚，他把每次的账目按  $1, 2, 3 \ldots$ 编号，然后不定时的问管家问题，问题是这样的：在   $a$ 到  $b$ 号账中最少的一笔是多少？为了让管家没时间作假，他总是一次问多个问题。

    ## 输入格式

    输入中第一行有两个数  $m, n$，表示有  $m$ 笔账  $n$ 表示有  $n$ 个问题。

    第二行为  $m$ 个数，分别是账目的钱数。

    后面  $n$ 行分别是  $n$ 个问题，每行有   $2$ 个数字说明开始结束的账目编号。

    ## 输出格式

    在一行中输出每个问题的答案，以一个空格分割。

    ## 样例 #1

    ### 样例输入 #1

    ```
    10 3
    1 2 3 4 5 6 7 8 9 10
    2 7
    3 9
    1 10
    ```

    ### 样例输出 #1

    ```
    2 3 1
    ```

    ## 提示

    对于 $100\%$ 的数据，$m \leq 10^5$，$n \leq 10^5$。

## 倍增区间法

可合并贡献问题：

如果一个区间 $[l, r]$ 可以分成两个子区间 $[l, k]$ 和 $[s, r]$ 并且这两个区间存在交集，那么 $[l, r]$ 的最小值就是 $[l, k]$ 和 $[s, r]$ 各自最小值的最小值.

可合并贡献或者说区间可重叠贡献、区间可持续贡献.

对于该题，假设给定了区间为：`a[1, n]`

先处理长度为 $1$ 的区间的最小值，再处理长度为 $2$ 的区间的最小值，接着处理长度为 $4$ 的区间的最小值，一直处理到长度为 $2 ^ {\left \lfloor log_2n \right \rfloor }$ 区间的最小值;

对于查询任意长度的区间 `[l, r]` 的最小值就是这两个区间 `[l, l + log(r - l + 1) - 1]` 和 `[r - log(r - l + 1) + 1, r]` 的最小值的最小值.

??? success "倍增区间表"

    ```c++
    LL n, m;
    LL a[N], lgn[N];
    LL bz[N][32];

    inline LL f(LL x) { return 1ll << x; }

    void solve(void)
    {
        n = gll(), m = gll();
        for (LL i = 1; i <= n; i ++) a[i] = gll();

        for (LL i = 2; i <= n; i ++) lgn[i] = lgn[i / 2] + 1;

        for (LL i = 1; i <= n; i ++) bz[i][0] = a[i];
        for (LL i = 1; i <= lgn[n]; i ++)
        {
            for (LL j = 1; j + f(i) - 1 <= n; j ++)
            {
                bz[j][i] = min(bz[j][i - 1], bz[j + f(i) - 1 - f(i - 1) + 1][i - 1]);
            }
        }

        for (LL i = 1; i <= m; i ++)
        {
            LL t1 = gll(), t2 = gll();
            LL len = t2 - t1 + 1;
            printf ("%lld ", min(bz[t1][lgn[len]], bz[t2 - f(lgn[len]) + 1][lgn[len]]));
        }
        puts("");
    }
    ```