# 国旗计划

??? question "[问题描述](https://www.luogu.com.cn/problem/P4155)"

    # [SCOI2015]国旗计划

    ## 题目描述

    A 国正在开展一项伟大的计划 —— 国旗计划。这项计划的内容是边防战士手举国旗环绕边境线奔袭一圈。这项计划需要多名边防战士以接力的形式共同完成，为此，国土安全局已经挑选了 $N$ 名优秀的边防战上作为这项计划的候选人。


    A 国幅员辽阔，边境线上设有 $M$ 个边防站，顺时针编号 $1$ 至 $M$。每名边防战士常驻两个边防站，并且善于在这两个边防站之间长途奔袭，我们称这两个边防站之间的路程是这个边防战士的奔袭区间。$N$ 名边防战士都是精心挑选的，身体素质极佳，所以每名边防战士的奔袭区间都不会被其他边防战士的奔袭区间所包含。


    现在，国十安全局局长希望知道，至少需要多少名边防战士，才能使得他们的奔袭区间覆盖全部的边境线，从而顺利地完成国旗计划。不仅如此，安全局局长还希望知道更详细的信息：对于每一名边防战士，在他必须参加国旗计划的前提下，至少需要多少名边防战士才能覆盖全部边境线，从而顺利地完成国旗计划。

    ## 输入格式

    第一行，包含两个正整数 $N,M$，分别表示边防战士数量和边防站数量。


    随后 $N$ 行，每行包含两个正整数。其中第 $i$ 行包含的两个正整数 $C_i$、$D_i$ 分别表示 $i$ 号边防战士常驻的两个边防站编号，$C_i$ 号边防站沿顺时针方向至 $D_i$ 号边防站力他的奔袭区间。数据保证整个边境线都是可被覆盖的。

    ## 输出格式

    输出数据仅 $1$ 行，需要包含 $N$ 个正整数。其中，第 $j$ 个正整数表示 $j$ 号边防战士必须参加的前提下至少需要多少名边防战士才能顺利地完成国旗计划。

    ## 样例 #1

    ### 样例输入 #1

    ```
    4 8
    2 5
    4 7
    6 1
    7 3
    ```

    ### 样例输出 #1

    ```
    3 3 4 3
    ```

    ## 提示

    $N\leqslant 2×10^5,M<10^9,1\leqslant C_i,D_i\leqslant M$。

## 暴力贪心

对于每一位边防战士来说：

如果跑完一圈必须包含该边防战士的路程时，先找一下该边防战士能够与谁接力？

找到这些能接力的边防战士，用贪心思想，将国旗交给跑地终点更远的战士.

时间复杂度：$O(n ^ 2)$

??? warning "Time limit exceed"

    ```c++
    LL n, m;
    struct Node
    {
        LL h, a, b, rs;
        bool operator<(const Node& tmp) const  
        { 
            return a < tmp.a; 
        }
    };

    Node q[N];

    #define f(x) (((x) - q[i].a + m) % m)

    void solve(void)
    {
        n = gll(), m = gll();
        for (LL i = 1; i <= n; i ++) q[i].h = i, q[i].a = gll(), q[i].b = gll(), q[i].rs = 0;

        sort(q + 1, q + 1 + n);

        for (LL i = 1; i <= n; i ++)
        {
            LL ct = 1, p = i, en = f(q[i].b);
            for (LL j = (i + 1 == n + 1 ? 1 : i + 1); ; j = (j + 1 == n + 1 ? 1 : j + 1))
            {
                // cout << q[j].h << " : " << q[j].a << " : " << q[j].b << endl;
                // cout << q[j].h << " : " << f(q[j].a) << " : " << f(q[j].b) << endl << endl;
                if (f(q[j].a) <= en)
                {
                    if ((f(q[j].b) > f(q[p].b))) p = j;
                    else if (f(q[j].b) < f(q[i].b))
                    {
                        q[i].rs = ct + 1; break;
                    }
                }
                else
                {
                    ct ++; 
                    j = p; en = f(q[p].b);
                }
            }
        }

        sort(q + 1, q + 1 + n, [](const Node& t1, const Node& t2) -> bool { return t1.h < t2.h; });

        for (LL i = 1; i <= n; i ++) printf ("%lld ", q[i].rs);
        cout << endl;
    }
    ```