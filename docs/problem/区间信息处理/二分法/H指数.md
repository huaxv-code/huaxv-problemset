# H指数

??? question "[问题描述](https://ac.nowcoder.com/acm/contest/46800/C)"

    某个学院内总共由 $n$ 位教授，每位教授 $i$ 手上都有一篇论文等待发布，每篇论文都有一定的热度 $h_i$;

    现在定义某位教授的 $H$ 指数为：该教授发表的论文数、每篇论文的热度都得大于数值 $H$，并且 $H$ 还是满足条件中的最大值；

    该学院想让这 $n$ 位教授的总 $H$ 指数之和最大化，允许某位教授拿取别人的论文来发布，但是每篇论文只能发表一次；允许没有教授发表论文的情况出现。

    **输入描述**

    第一行输入一个整数 $T$ 代表测试样例的数量；

    对于每个测试样例，第一行输入一个整数 $n$ 代表当前测试样例的教授数量；第二行输入 $n$ 个整数，分别代表各自教授手中的论文的热度；

    **输出描述**

    输出 $T$ 行；每行代表对应测试样例的最大 $H$ 指数和。

    **输入样例**

    ```
    2
    3
    6 5 4
    2
    10 0
    ```

    **输出样例**

    ```
    3
    1
    ```

## 二分枚举个数

假设我们使用数组 $a[1 \sim n]$ 来从小到大存储论文的热度，那么第 1 位教授应该拿取多少篇论文才能使得他的 $H$ 指数最高呢？

- 如果他拿了最大的 $x$ 篇论文，并且这 $x$ 篇论文的热度值都大于 $x$，说明可以获得热度值 $x$；
- 如果他拿了最大的 $x$ 篇论文，发现这 $x$ 篇论文中的最小热度值小于 $x$，就说明该教授拿多几篇小热度的论文害的总体的热度值变小了，该教授丢弃那几篇小热度值的论文，热度值反而还会变大；

因此我们需要用二分查找这个 $x$ 值的最大值，该最大值就作为当前教授的最大 $H$ 指数；

然后对于剩下的论文也采取上面的思考方式查找；

如果我们发现查找到的 $x = 0$ 时，就说明剩下的论文都是 $0$ 热度的，就没有继续查找的必要了，剩下的论文无论怎么组合，热度值都会为 $0$，程序就可以结束运行；

时间复杂度为：$O(nlog(n))$

??? success "代码参考"

    ```c++
    LL t, n, q[N], res;
    LL l, r, mid, s, e;

    // 是否拿出的 x 篇论文的热度值都不低于 x
    // 如果有低于 x 的话，那么 x 就得适当小，
    // 并抛弃掉热度值小的论文，留给剩下的教授发表
    bool ok(LL l, LL r, LL x)
    {
        if (x > (r - l + 1)) return false;
        return q[(r - x + 1)] >= x;
    }

    void solve(void)
    {
        cin >> t;
        while (t --)
        {
            cin >> n;
            for (LL i = 1; i <= n; i ++) cin >> q[i];
            sort(q + 1, q + 1 + n);
            s = 1, e = n, res = 0;
            while (e > 0) // 如果剩下的论文数量为 0 时就可以结束循环
            {
                // 发布的论文数的区间一定在 [0, e] 之间
                l = 0, r = e;
                while (l < r)
                {
                    mid = (l + r + 1) / 2;
                    if (ok(s, e, mid)) l = mid;
                    else r = mid - 1;
                }
                res += l; // 各个教授的热度值累加
                if (l == 0) break; // 剩下的论文热度值都是 0
                e -= l; // 抛弃掉已经发布了的 l 篇论文，剩下的论文就是 [1, e - l]
            }
            cout << res << endl;
        }
    }
    ```

## 贪心

我们通过上面的二分其实不难发现答案在数值上完全等同于 *总论文数 - 热度值为 0 的论文数*；

假设第一位教授那了前面 $x$ 篇论文，第二位教授拿了剩下的前面 $y$ 篇论文，一直到第 $s$ 位教授拿了剩下最大的 $k$ 篇论文，那么剩下那些教授都没有拿的话，说明没有论文剩下，或者说明剩下的论文的热度值都为 $0$，没有拿的必要；

而 $x + y + \cdots + k$ 就恰好等于 *总论文数 - 热度值为 0 的论文数*；

时间复杂度为：$O(n)$

??? success "代码参考"

    ```c++
    LL t, n, q[N], cnt;

    void solve()
    {
        cin >> t;
        while (t --)
        {
            cin >> n; cnt = 0;
            for (LL i = 1; i <= n; i ++)
            {
                cin >> q[i]; if (q[i]) cnt ++;
            }
            cout << cnt << endl;
        }
    }
    ```