# 滑动窗口

## 离散化 + 桶 + 线段树

??? success "代码参考"

    ```java
    int n, m;

    int as[N];
    int st[N], ct;
    int tr[N << 2];
    int tg[N << 2];

    int mis[N], mxs[N], mict, mxct;

    inline int lc(int p) { return p << 1; }
    inline int rc(int p) { return p << 1 | 1; }

    int lf(int x, int l, int r) {
        int mid;
        while (l < r) {
            mid = (l + r) >> 1;
            if (st[mid] < x) l = mid + 1;
            else r = mid;
        }
        if (st[r] == x) return r;
        return -1;
    }

    int unique(int nums[], int l, int r) {
        int i = l, j = l + 1;
        while (j < r) {
            if (nums[i] != nums[j]) {
                nums[++ i] = nums[j];
            }
            j ++;
        }
        return i;
    }

    void pushUp(int p, int l, int r) {
        if (l == r) return;
        tr[p] = tr[lc(p)] + tr[rc(p)];
    }

    void sett(int p, int l, int r, int x) {
        tg[p] += x;
        tr[p] += (r - l + 1) * x;
    }

    void pushDown(int p, int l, int r) {
        if (l == r) return;

        int mid = (l + r) >> 1;
        sett(lc(p), l, mid, tg[p]);
        sett(rc(p), mid + 1, r, tg[p]);

        tg[p] = 0;
        pushUp(p, l, r);
    }

    void build(int p, int l, int r) {
        ;
    }

    void update(int p, int l, int r, int ll, int rr, int x) {
        if (ll <= l && r <= ll) {
            sett(p, l, r, x);
            return;
        }

        int mid = (l + r) >> 1;

        if (ll <= mid) {
            update(lc(p), l, mid, ll, rr, x);
        }
        if (rr > mid) {
            update(rc(p), mid + 1, r, ll, rr, x);
        }

        pushUp(p, l, r);
    }

    int min(int p, int l, int r, int ll, int rr, int k) {
        if (l == r) return l;
        int mid = (l + r) >> 1;

        if (ll <= mid && tr[lc(p)] >= k) {
            return min(lc(p), l, mid, ll, rr, k);
        }
        return min(rc(p), mid + 1, r, ll, rr, k - tr[lc(p)]);
    }

    int max(int p, int l, int r, int ll, int rr, int k) {
        if (l == r) return l;
        int mid = (l + r) >> 1;

        if (rr > mid && tr[rc(p)] >= k) {
            return max(rc(p), mid + 1, r, ll, rr, k);
        }
        return max(lc(p), l, mid, ll, rr, k - tr[rc(p)]);
    }


    void solve(void) {
        
        n = gll(), m = gll();

        for (int i = 1; i <= n; i ++) {
            as[i] = gll(); st[i] = as[i];
        }

        sort(st + 1, st + 1 + n);
        ct = unique(st, 1, n + 1);

        for (int i = 1; i < m; i ++) {
            int ll, rr;
            ll = rr = lf(as[i], 1, ct);
            update(1, 1, ct, ll, rr, 1);
        }

        for (int i = m; i <= n; i ++) {
            int ll, rr;
            ll = rr = lf(as[i], 1, ct);
            update(1, 1, ct, ll, rr, 1);
            if (i > m) {
                int lll, rrr;
                lll = rrr = lf(as[i - m], 1, ct);
                update(1, 1, ct, lll, rrr, -1);
            }
            int mi = min(1, 1, ct, 1, ct, 1);
            int mx = max(1, 1, ct, 1, ct, 1);
            mis[++ mict] = st[mi];
            mxs[++ mxct] = st[mx];
        }

        for (int i = 1; i <= mict; i ++) {
            pll(mis[i], " ");
        }
        puts("");
        for (int i = 1; i <= mxct; i ++) {
            pll(mxs[i], " ");
        }
        puts("");
    }
    ```