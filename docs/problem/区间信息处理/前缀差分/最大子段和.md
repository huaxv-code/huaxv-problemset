# 最大子段和

??? question "题目描述"

    # 最大子段和

    ## 题目描述

    给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。

    ## 输入格式

    第一行是一个整数，表示序列的长度 $n$。

    第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。

    ## 输出格式

    输出一行一个整数表示答案。

    ## 样例 #1

    ### 样例输入 #1

    ```
    7
    2 -4 3 -1 2 -4 3
    ```

    ### 样例输出 #1

    ```
    4
    ```

    ## 提示

    #### 样例 1 解释

    选取 $[3, 5]$ 子段 $\{3, -1, 2\}$，其和为 $4$。

    #### 数据规模与约定

    - 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^3$。
    - 对于 $100\%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。

## 前缀差分、双指针滑动窗口

如果一个区间有正数的情况下：

如果一个区间的和是正数，那么该区间很有可能会作为最大和连续区间的一部分；

如果区间的和最大，那么区间的开头和末尾一定是正数；

如果一个区间加上一个负数之后的和仍为正数，那么当前区间也还是有可能作为最大和连续区间的左边部分或右边部分；

如果一个区间加上一个负数之后的和为负数，那么当前区间一定不会作为最大和连续区间的一部分；

如果区间全为负数，那么最大值就是最大和；

??? success "代码参考"

    ```c++
    LL n, pre[N], res = -1e9;

    void solve(void)
    {
        cin >> n; 
        for (LL i = 1; i <= n; i ++) 
        {
            LL t; cin >> t; pre[i] = pre[i - 1] + t;
        }
        LL i = 1, j = 1;
        while (j <= n)
        {
            LL t = pre[j] - pre[i - 1];
            if (t < 0) i = j + 1;
            res = max(res, t);
            j ++;
        }
        cout << res << endl;
    }
    ```