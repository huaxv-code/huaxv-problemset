# 多重背包

[例子会加深认知]()

??? question "[问题描述](https://www.luogu.com.cn/problem/P1776)"

    背包容量为 $m$，物品种类有 $n$ 种.

    对于第 $i$ 种物品，其体积为 $v_i$，价值为 $w_i$，个数有 $c_i$ 个.

    请你求出该背包的最高价值.

    **数据范围**

    $n \leq \sum c_i \leq 10 ^ 5$

    $0 \leq m \leq 4 * 10 ^ 4$

    $1 \leq n \leq 100$

    **输入输出**

    【输入格式】

    第一行输入两个整数分别代表 $n$ 和 $m$

    接下来的 $n$ 行，每行 $3$ 个整数分别代表 $w_i, v_i, c_i$

    【输出格式】

    输出只有一个整数，代表背包的最高价值

    **样例一**

    输入：

    ```
    4 20
    3 9 3
    5 9 1
    9 4 2
    8 1 3
    ```

    输出：

    ```
    47
    ```

## 多重背包

$dp[i][j]$ 代表将前面 $i$ 种物品放入容量为 $j$ 的背包当中.

摆在 $dp[i][j]$ 的问题是当前种类 $i$ 的物品到底要不要放入？如果放入要放多少个？

如果不放入，那么容量为 $j$ 的背包的最高价值就是将前 $i-1$ 种物品放入的背包的最高价值，即：$dp[i-1][j]$

如果放入，且放入 $k$ 个，那么最高价值就是 $\min(dp[i][j], dp[i-1][j - k * v[i]] + k * w[i])$

一一枚举并记录最优值

时间复杂度：$O(n * m)$ 总个数乘上总容量.

??? warning "代码参考"

    代码超时

    ```c++
    LL n, m, v[N], w[N], c[N];
    LL dp[110][100000];

    void solve(void)
    {
        n = gll(), m = gll();
        for (LL i = 1; i <= n; i ++)
            w[i] = gll(), v[i] = gll(), c[i] = gll();

        for (LL i = 1; i <= n; i ++)
        {
            for (LL j = 1; j <= m; j ++)
            {
                for (LL k = 0; k <= c[i]; k ++)
                {
                    if (j - k * v[i] >= 0)
                        dp[i][j] = max(dp[i][j], dp[i - 1][j - k * v[i]] + k * w[i]);
                    else break;
                }
            }
        }

        pll(dp[n][m]);
    }
    ```

**滚动数组，从右向左遍历背包容量**

时间复杂度也是：$O(n * m)$ 总个数乘上总容量.

??? warning "滚动数组"

    代码超时

    ```c++
    LL n, m, v[N], w[N], c[N];
    LL dp[100000];

    void solve(void)
    {
        n = gll(), m = gll();
        for (LL i = 1; i <= n; i ++)
            w[i] = gll(), v[i] = gll(), c[i] = gll();

        for (LL i = 1; i <= n; i ++)
        {
            for (LL j = m; j >= 0; j --)
            {
                for (LL k = 0; k <= c[i]; k ++)
                {
                    if (j - k * v[i] >= 0)
                        dp[j] = max(dp[j], dp[j - k * v[i]] + k * w[i]);
                    else break;
                }
            }
        }

        pll(dp[m]);
    }
    ```

**二进制拆分优化时间复杂度**

我们先思考，如果将该问题转化成 *01 背包问题* 时，将 *多重背包* 看成 *01 背包*，暴力代码：

!!! note "01 背包问题暴力代码"

    ```c++
    LL n, m, v[N], w[N], cnt;
    LL dp[N];

    void solve(void)
    {
        n = gll(); m = gll();
        for (LL i = 1; i <= n; i ++)
        {
            LL a, b, c;
            a = gll(), b = gll(), c = gll();

            while (c --) { ++ cnt; w[cnt] = a, v[cnt] = b; }
        }

        n = cnt;

        for (LL i = 1; i <= n; i ++)
        {
            for (LL j = m; j; j --)
            {
                if (j - v[i] >= 0)
                    dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
            }
        }

        pll(dp[m]);
    }
    ```

时间复杂度也是：$O(n * m)$ 总个数乘上总容量.

假设最优的结果需要从第 $i$ 种物品中选取 $k$ 个，但实际 $i$ 有 $c > k$ 个，我们转换为 *01 背包问题* 时放入了 $c$ 个 $i$ 物品进去组合成 $k$，实际上可以从二进制的计算原理，不必放入 $c$ 个数进去，放入 $c$ 个数进去可以组合成 $c$ 种情况，即 $0 \leq c$ 如果将 $c$ 拆分成二进制的形式，例如 $25 = 0  1 + 2 + 4 + 8 + 10$ 放进去组合，也是可以组合出 $0 \leq 25$ 种组合出来。

??? info "使用 $0、1、2、4、8、10$ 只能组合出下面这些数"

    ```
    0
    1
    2
    3 = 1 + 2
    4
    5 = 1 + 4
    6 = 2 + 4
    7 = 1 + 2 + 4
    8 
    9 = 1 + 8
    10 = 2 + 8
    11 = 1 + 2 + 8
    12 = 4 + 8
    13 = 1 + 4 + 8
    14 = 2 + 4 + 8
    15 = 1 + 2 + 4 + 8
    16 = 2 + 4 + 10
    17 = 1 + 2 + 4 + 10
    18 = 8 + 10
    19 = 1 + 8 + 10
    20 = 2 + 8 + 10
    21 = 1 + 2 + 8 + 10
    22 = 4 + 8 + 10
    23 = 1 + 4 + 8 + 10
    24 = 2 + 4 + 8 + 10
    28 = 1 + 2 + 4 + 8 + 10
    ```

所以我们不必放入 $25$ 个物件 $i$ 只需要放入 $i$、$2*i$、$4 * i$、$8 * i$、$10 * i$ 剩下的背包会自动帮我们组合出最优解：

!!! success "二进制拆分优化"

    ```c++
    LL n, m, v[N], w[N], cnt;
    LL dp[N];

    void solve(void)
    {
        n = gll(); m = gll();
        for (LL i = 1; i <= n; i ++)
        {
            LL a, b, c;
            a = gll(), b = gll(), c = gll();

            LL t = 1;
            while (t <= c) // 处理二进制拆分数
            {
                ++ cnt;
                w[cnt] = t * a;
                v[cnt] = t * b;
                c -= t;
                t *= 2;
            }

            if (c) // 处理余数
            {
                ++ cnt;
                w[cnt] = c * a;
                v[cnt] = c * b;
            }
        }

        n = cnt;

        for (LL i = 1; i <= n; i ++)
        {
            for (LL j = m; j; j --)
            {
                if (j - v[i] >= 0)
                    dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
            }
        }

        pll(dp[m]);
    }
    ```