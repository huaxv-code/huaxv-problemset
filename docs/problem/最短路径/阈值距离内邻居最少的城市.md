# [阈值距离内邻居最少的城市](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/)

=== "矩阵乘法"

    求出所有点对之间的最短路径.

    **优势：能控制路径边数的所有点对最短路径**

    时间复杂度：$O(n ^ 4)$.

    ```java
    class Solution {

        long inf = 1L << 31;

        long[][] mmul(long[][] a, long[][] b, int n) {
            long[][] res = new long[n][n];

            for (int i = 0; i < n; i ++) {
                for (int j = 0; j < n; j ++) {
                    res[i][j] = inf;
                }
            }

            for (int i = 0; i < n; i ++) {
                for (int j = 0; j < n; j ++) {
                    for (int k = 0; k < n; k ++) {
                        res[i][j] = Math.min(res[i][j], a[i][k] + b[k][j]);
                    }
                }
            }

            return res;
        }

        // void print(long[][] a, int n) {
        //     for (int i = 0; i < n; i ++) {
        //         for (int j = 0; j < n; j ++) {
        //             if (a[i][j] != inf) System.out.print(a[i][j] + " ");
        //             else System.out.print("0 ");
        //         }
        //         System.out.println();
        //     }
        //     System.out.println();
        // }

        int n, m;
        long[][] g, res;
        long[][] on;
        long[] as;

        boolean cnt(long[][] a) {
            int ct = 0;
            for (int i = 0; i < n; i ++) {
                for (int j = 0; j < n; j ++) {
                    if (i == j || on[i][j] > 0 || a[i][j] > m) {
                        ct ++;
                        continue;
                    }
                    as[i] ++; on[i][j] = 1;
                }
            }
            return ct != n * n;
        }

        public int findTheCity(int ns, int[][] edges, int distanceThreshold) {
            n = ns; m = distanceThreshold;
            g = new long[n][n];
            res = new long[n][n];
            on = new long[n][n];
            as = new long[n];

            for (int i = 0; i < n; i ++) {
                for (int j = 0; j < n; j ++) {
                    g[i][j] = inf;
                    res[i][j] = inf;
                }
            }

            for (int i = 0; i < edges.length; i ++) {
                int aa = edges[i][0];
                int ab = edges[i][1];
                int ac = edges[i][2];

                g[ab][aa] = g[aa][ab] = ac;
                res[ab][aa] = res[aa][ab] = ac;
            }

            // print(res, n);

            if (cnt(res)) {
                for (int i = 1; i < n; i ++) {
                    res = mmul(res, g, n);
                    // print(res, n);
                    if (cnt(res) == false) break;
                }
            }

            long mn = inf;
            for (int i = 0; i < n; i ++) {
                // System.out.println(as[i]);
                // if (as[i] == 0L) continue;
                mn = Math.min(mn, as[i]);
            }

            for (int i = n - 1; i > 0; i --) {
                if (as[i] == mn) {
                    return i;
                }
            }

            return 0;
        }
    }
    ```

=== "Floyd: 弗洛伊德"

    能求出所有点对之间的最短路径，并且时间复杂度只需 $O(n ^ 3)$

    **缺点：不能控制边数的所有点对最短路径**

    代码上与矩阵乘法几乎雷同！

    设计思路：

    如果我们已经求出了前面能经过 $1 ~ k - 1$ 个点的任意两个点对之间的最短路径，那么如果允许经过新点 $k$ 是否会造成最短路径变得更短呢？

    比较点对 $(i, j)$ 不经过 $k$ 的最短路径与经过 $k$ 的最短路，两者取最小

    > `dp[k][i][j] = min(dp[k - 1][i][j], dp[k - 1][i][k] + dp[k - 1][k][j])`

    `dp[k][i][j]` 表示能经过前面 $1 ~ k$ 个点的 $i$ 到 $j$ 的最短路径.

    ```java
    class Solution {

        long[][][] dp;
        long[] as;
        long inf = 1L << 31;
        int n, m;

        public int findTheCity(int ns, int[][] edges, int distanceThreshold) {
            n = ns;
            m = distanceThreshold;

            dp = new long[n + 1][n + 1][n + 1];
            as = new long[n + 1];

            for (int i = 0; i <= n; i ++) {
                for (int j = 0; j <= n; j ++) {
                    for (int k = 0; k <= n; k ++) {
                        dp[i][j][k] = inf;
                    }
                }
            }

            for (int i = 0; i < edges.length; i ++) {
                int aa = edges[i][0] + 1;
                int ab = edges[i][1] + 1;
                int ac = edges[i][2];

                dp[0][aa][ab] = ac;
                dp[0][ab][aa] = ac;
            }

            for (int i = 1; i <= n; i ++) {
                for (int j = 1; j <= n; j ++) {
                    for (int k = 1; k <= n; k ++) {
                        dp[i][j][k] = Math.min(dp[i - 1][j][k], dp[i - 1][j][i] + dp[i - 1][i][k]);
                    }
                }
            }

            for (int i = 1; i <= n; i ++) {
                for (int j = 1; j <= n; j ++) {
                    // System.out.print(dp[n][i][j] + " ");
                    if (i == j) continue;
                    if (dp[n][i][j] <= m) as[i] ++;
                }

                // System.out.println();
            }

            long mn = inf;

            for (int i = 1; i <= n; i ++) {
                mn = Math.min(mn, as[i]);
            }

            for (int i = n; i > 0; i --) {
                if (as[i] == mn) return i - 1;
            }

            return -1;
        }
    }
    ```