# [阈值距离内邻居最少的城市](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/)

=== "矩阵乘法"

    求出所有点之间的最短路径.

    时间复杂度：$O(n ^ 4)$.

    ```java
    class Solution {

        long inf = 1L << 31;

        long[][] mmul(long[][] a, long[][] b, int n) {
            long[][] res = new long[n][n];

            for (int i = 0; i < n; i ++) {
                for (int j = 0; j < n; j ++) {
                    res[i][j] = inf;
                }
            }

            for (int i = 0; i < n; i ++) {
                for (int j = 0; j < n; j ++) {
                    for (int k = 0; k < n; k ++) {
                        res[i][j] = Math.min(res[i][j], a[i][k] + b[k][j]);
                    }
                }
            }

            return res;
        }

        // void print(long[][] a, int n) {
        //     for (int i = 0; i < n; i ++) {
        //         for (int j = 0; j < n; j ++) {
        //             if (a[i][j] != inf) System.out.print(a[i][j] + " ");
        //             else System.out.print("0 ");
        //         }
        //         System.out.println();
        //     }
        //     System.out.println();
        // }

        int n, m;
        long[][] g, res;
        long[][] on;
        long[] as;

        boolean cnt(long[][] a) {
            int ct = 0;
            for (int i = 0; i < n; i ++) {
                for (int j = 0; j < n; j ++) {
                    if (i == j || on[i][j] > 0 || a[i][j] > m) {
                        ct ++;
                        continue;
                    }
                    as[i] ++; on[i][j] = 1;
                }
            }
            return ct != n * n;
        }

        public int findTheCity(int ns, int[][] edges, int distanceThreshold) {
            n = ns; m = distanceThreshold;
            g = new long[n][n];
            res = new long[n][n];
            on = new long[n][n];
            as = new long[n];

            for (int i = 0; i < n; i ++) {
                for (int j = 0; j < n; j ++) {
                    g[i][j] = inf;
                    res[i][j] = inf;
                }
            }

            for (int i = 0; i < edges.length; i ++) {
                int aa = edges[i][0];
                int ab = edges[i][1];
                int ac = edges[i][2];

                g[ab][aa] = g[aa][ab] = ac;
                res[ab][aa] = res[aa][ab] = ac;
            }

            // print(res, n);

            if (cnt(res)) {
                for (int i = 1; i < n; i ++) {
                    res = mmul(res, g, n);
                    // print(res, n);
                    if (cnt(res) == false) break;
                }
            }

            long mn = inf;
            for (int i = 0; i < n; i ++) {
                // System.out.println(as[i]);
                // if (as[i] == 0L) continue;
                mn = Math.min(mn, as[i]);
            }

            for (int i = n - 1; i > 0; i --) {
                if (as[i] == mn) {
                    return i;
                }
            }

            return 0;
        }
    }
    ```