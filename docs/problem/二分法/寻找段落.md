# 寻找段落

??? question "[问题描述](https://www.luogu.com.cn/problem/P1419)"

    # 寻找段落

    ## 题目描述

    给定一个长度为 $n$ 的序列 $a$，定义 $a_i$ 为第 $i$ 个元素的价值。现在需要找出序列中最有价值的“段落”。段落的定义是长度在 $[S, T]$ 之间的连续序列。最有价值段落是指平均值最大的段落。

    **段落的平均值** 等于 **段落总价值** 除以 **段落长度**。

    ## 输入格式

    第一行一个整数 $n$，表示序列长度。

    第二行两个整数 $S$ 和 $T$，表示段落长度的范围，在 $[S, T]$ 之间。

    第三行到第 $n+2$ 行，每行一个整数表示每个元素的价值指数。

    ## 输出格式

    一个实数，保留 $3$ 位小数，表示最优段落的平均值。

    ## 样例 #1

    ### 样例输入 #1

    ```
    3
    2 2
    3
    -1
    2
    ```

    ### 样例输出 #1

    ```
    1.000
    ```

    ## 提示

    【数据范围】

    对于 $30\%$ 的数据有 $n \le 1000$。

    对于 $100\%$ 的数据有 $1 \le n \le 100000$，$1 \le S \le T \le n$，$-{10}^4 \le a_i \le {10}^4$。

    【题目来源】

    tinylic 改编

## 二分

二分枚举最优段落的平均值：

如果该平均值符合条件，就往大的方向枚举；

如果该平均值不符合条件，就说明该平均值太大了，要往小的方向枚举；

暴力判断超时：

时间复杂度估计：$O(n ^ 2 log(n))$

??? warning "超时代码"

    ```c++
    LL n, s, t;
    double a[N], sb[N];
    double eps = 1e-14, es = 1e-4;

    bool ok(double x)
    {
        double sum = 0;
        for (LL i = 1; i + s - 1 <= n; i ++)
        {
            for (LL j = s; j <= t; j ++)
            {
                if (i + j - 1 > n) break;
                if (sb[i + j - 1] - sb[i - 1] >= x * j) return true;
            }
        }
        return false;
    }

    void solve(void)
    {
        cin >> n >> s >> t;
        for (LL i = 1; i <= n; i ++) 
        {
            cin >> a[i]; sb[i] = a[i] + sb[i - 1];
        }

        double l, r, mid;

        l = -1e9, r = 1e9;
        while (r - l >= es)
        {
            mid = (l + r) / 2;
            if (ok(mid)) l = mid;
            else r = mid;
        }

        printf ("%.3f\n", l);
    }
    ```