# 砍原木

??? question "[问题描述](https://www.luogu.com.cn/problem/T307305?contestId=98395)"

    给你 $n$ 个原木，长度分别是 $A_1, A_2, \cdots, A_n$.

    你最多只能砍 $m$ 刀，当长度为 $l$ 的原木，在 $t$ 处砍了一刀，这该原木就分成了长度为 $t$ 和 $l - t$ 两颗原木.

    请你找出最多砍 $m$ 刀后，最长原木的最短长度是多少，并将他四舍五入为整数.

    **数据范围**

    $1 \leq n \leq 2 \times 10 ^ 5$

    $1 \leq m, A_i \leq 10 ^ 9$

    **输入描述**

    第一行：两个整数分别代表 $n、m$；

    第二行：$n$ 个整数，分别代表 $A_1, A_2, \cdots, A_n$.

    **输出描述**

    一个整数：代表最长原木的最短长度，并将他四舍五入为整数.

    **示例一**

    输入：

    ```
    10 10
    158260522 877914575 602436426 24979445 861648772 623690081 433933447 476190629 262703497 211047202
    ```

    输出：

    ```
    292638192
    ```

## 二分

??? success "代码参考"

用二分枚举答案：

如果实际砍数小于只能砍数，说明值满足条件，需要向下枚举；

如果实际砍数大于只能砍树，说明值不满足条件，太小了，砍得多了，需要向上枚举；

最后的答案要求四舍五入，

即要求实际砍数与只能砍数，相差最近的才是正确答案。

    ```c++
    LL n, m, a[N];

    LL ok(LL x)
    {
        if (x == 0) return 1e18;
        LL cnt = 0;
        for (LL i = 1; i <= n; i ++)
        {
            cnt += a[i] / x;
            if (a[i] % x == 0) cnt --;
        }
        return cnt;
    }

    void solve(void)
    {
        cin >> n >> m;
        for (LL i = 1; i <= n; i ++) cin >> a[i];
        LL l, r, mid;
        l = 0, r = 1e9 + 10;
        while (l < r)
        {
            mid = (l + r) / 2;
            if (ok(mid) <= m) r = mid;
            else l = mid + 1;
        }
        if (m - ok(r) <= ok(l) - m) cout << r << endl;
        else cout << l << endl;
    }
    ```